## 포인트컷 지시자

**포인트컷 지시자**

포인트컷 표현식은 `execution` 같은 포인트컷(Pointcut Designator) 지시자로 시작한다. 줄여서 PCD라 한다.

- 포인트컷 지시자의 종류
  - `execution` : 메서드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡함
  - `within` : 특정 타입 내의 조인 포인트를 매칭한다.
  - `args` : 인자가 주어진 타입의 인스턴스인 조인 포인트
  - `this` : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
  - `target` : Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)을 대상으로 하는 조인 포인트
  - `@target` : 실행 객체의 클래스에 저이진 타입의 애노테이션이 있는 조인 포인트
  - `@within` : 주어진 애노테이션이 있는 타입 내 조인 포인트
  - `@annotation` : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
  - `@args` : 전달된 실제 인수의 런타임 타임이 주어진 타입의 애노테이션을 갖는 조인 포인트
  - `bean` : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다.

## 예제 만들기

```java
package hello.aop.member.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ClassAop {
}
```

```java
package hello.aop.member.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MethodAop {
    String value();
}
```

```java
package hello.aop.member;

public interface MemberService {
    String hello(String param);
}
```

```java
package hello.aop.member;

import hello.aop.member.annotation.ClassAop;
import hello.aop.member.annotation.MethodAop;
import org.springframework.stereotype.Component;

@ClassAop
@Component
public class MemberServiceImpl implements MemberService{
    @Override
    @MethodAop("test value")
    public String hello(String param) {
        return "ok";
    }

    public String internal(String param) {
        return "ok";
    }
}
```

```java
package hello.aop.pointcut;

import hello.aop.member.MemberServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.aop.aspectj.AspectJExpressionPointcut;

import java.lang.reflect.Method;

@Slf4j
public class ExecutionTest {

    AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
    Method helloMethod;

    @BeforeEach
    public void init() throws NoSuchMethodException {
         helloMethod = MemberServiceImpl.class.getMethod("hello", String.class);
    }

    @Test
    void printMethod() {
        log.info("helloMethod={}", helloMethod);
    }
}
```

## execution1

`execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?)`

- 메서드 실행 조인 포인트를 매칭
- ? 생략 가능
- `*` 같은 패턴을 지정할 수 있음

```java
@Test
void exactMatch() {
    pointcut.setExpression("execution(public String hello.aop.member.MemberServiceImpl.hello(String))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

**매칭 조건**

- 접근제어자? : `public`
- 반환타입 : `String`
- 선언타입? : `hello.aop.member.MemberServiceImpl`
- 메서드 이름 : `hello`
- 파라미터 : `String`
- 예외? : 생략

```java
@Test
    void allMatch() {
        pointcut.setExpression("execution(* *(..))");
        Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
    }
```

**매칭 조건**

- 접근제어자? : 생략
- 반환타입 : `*`
- 선언타입? : 생략
- 메서드 이름 : `*`
- 파라미터 : `(..)`
- 예외? : 생략

- `*` 은 아무 값이 들어와도 된다는 뜻
- 파라미터에서 `..` 은 파라미터의 타입과 파라미터 수가 상관없다는 뜻이다.

```java
@Test
void nameMatchStar1() {
    pointcut.setExpression("execution(* hel*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void nameMatchStar2() {
    pointcut.setExpression("execution(* *el*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void nameMatchFalse() {
    pointcut.setExpression("execution(* nono(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

@Test
void packageExactMatch1() {
    pointcut.setExpression("execution(* hello.aop.member.MemberServiceImpl.hello(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageExactMatch2() {
    pointcut.setExpression("execution(* hello.aop.member.*.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageExactFalse() {
    pointcut.setExpression("execution(* hello.aop.*.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

@Test
void packageMatchSubPackage1() {
    pointcut.setExpression("execution(* hello.aop.member..*.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void packageMatchSubPackage2() {
    pointcut.setExpression("execution(* hello.aop..*.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

패키지에서 `.` ,`..` 의 차이

- `.` : 정확하게 해당 위치의 패키지
- `..` : 해당 위치의 패키지와 그 하위 패키지도 포함

## execution2

**타입 매칭 - 부모 타입 허용**

```java
@Test
void typeExactMatch() {
    pointcut.setExpression("execution(* hello.aop.member.MemberServiceImpl.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void typeMatchSuperType() {
    pointcut.setExpression("execution(* hello.aop.member.MemberService.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

`typeExactMatch()` 는 타입 정보가 정확하게 일치하기 때문에 매칭된다.

`typeMatchSuperType()` 을 주의해서 보아야 한다.

`execution` 에서는 `MemberService` 처럼 부모 타입을 선언해도 그 자식 타입은 매칭된다. 다형성에서 `부모타입 = 자식타입` 이 할당 가능하다는 점을 떠올려보면 됨

**타입 매칭 - 부모 타입에 있는 메서드만 허용**

```java
@Test
void typeMatchInternal() throws NoSuchMethodException {
    Method internalMethod = MemberServiceImpl.class.getMethod("internal", String.class);
    pointcut.setExpression("execution(* hello.aop.member.MemberServiceImpl.*(..))");
    Assertions.assertThat(pointcut.matches(internalMethod, MemberServiceImpl.class)).isTrue();
}

@Test
void typeMatchNoSuperTypeMethodFalse() throws NoSuchMethodException {
    Method internalMethod = MemberServiceImpl.class.getMethod("internal", String.class);
    pointcut.setExpression("execution(* hello.aop.member.MemberService.*(..))");
    Assertions.assertThat(pointcut.matches(internalMethod, MemberServiceImpl.class)).isFalse();
}
```

**파라미터 매칭**

```java
// String 타입의 파라미터 허용
// (String)
@Test
void argsMatch() {
    pointcut.setExpression("execution(* *(String))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// 파라미터가 없어야 함
// ()
@Test
void argsMatchNoArgs() {
    pointcut.setExpression("execution(* *())");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

// 정확히 하나의 파라미터 허용, 모든 타입 허용
// (Xxx)
@Test
void argsMatchNoStars() {
    pointcut.setExpression("execution(* *(*))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// 숫자와 무관하게 모든 파라미터, 모든 타입 허용
// (), (Xxx), (Xxx, Xxx)
@Test
void argsMatchAll() {
    pointcut.setExpression("execution(* *(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}

// String 타입으로 시작,  숫자와 무관하게 모든 파라미터, 모든 타입 허용
// (String), (String, Xxx), (String, Xxx, Xxx)
@Test
void argsMatchComplex() {
    pointcut.setExpression("execution(* *(String, ..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

**execution 파라미터 매칭 규칙**

- `(String)` : 정확하게 String 타입 파라미터
- `()` : 파라미터가 없어야 함
- `(*)` : 정확히 하나의 파라미터, 단 모든 타입 허용
- `(*, *)` : 정확히 두 개의 파라미터, 단 모든 타입을 허용
- `(..)` : 숫자와 무관하게 모든 파라미터, 모든 타입을 허용. 참고로 파라미터가 없어도 됨
- `(String, ..)` : String 타입으로 시작해야 함. 숫자와 무관하게 모든 파라미터, 모든 타입을 허용

## within

특정 타입 내의 조인 포인트에 대한 매칭을 제한. 쉽게 말해서 해당 타입이 매칭되면 그 안의 메서드(조인 포인트) 들이 자동으로 매칭

문법은 단순한데 `execution` 에서 타입 부분만 사용한다고 보면 됨

```java
package hello.aop.pointcut;

import hello.aop.member.MemberServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.aop.aspectj.AspectJExpressionPointcut;

import java.lang.reflect.Method;

@Slf4j
public class WithinTest {

    AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
    Method helloMethod;

    @BeforeEach
    public void init() throws NoSuchMethodException {
        helloMethod = MemberServiceImpl.class.getMethod("hello", String.class);
    }

    @Test
    void withinExact() {
        pointcut.setExpression("within(hello.aop.member.MemberServiceImpl)");
        Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
    }

    @Test
    void withinStar() {
        pointcut.setExpression("within(hello.aop.member.*Service*)");
        Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
    }

    @Test
    void withinSubPackage() {
        pointcut.setExpression("within(hello.aop..*)");
        Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
    }
}
```

**주의**

**표현식에 부모 타입을 지정하면 안됨.** 정확하게 타입이 맞아야 한다.

→ 이 부분에서 `execution` 과 차이가 난다.

```java
@Test
@DisplayName("타겟의 타입에만 직접 적용, 인터페이스를 선정하면 안된다.")
void withinSuperTypeFalse() {
    pointcut.setExpression("within(hello.aop.member.MemberService)");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isFalse();
}

@Test
@DisplayName("execution은 타입 기반, 인터페이스 선정 가능 타겟의 타입에만 직접 적용, 인터페이스를 선정하면 안된다.")
void executionSuperTypeTrue() {
    pointcut.setExpression("execution(* hello.aop.member.MemberService.*(..))");
    Assertions.assertThat(pointcut.matches(helloMethod, MemberServiceImpl.class)).isTrue();
}
```

## args

- `args` : 인자가 주어진 타입의 인스턴스인 조인 포인트로 매칭
- 기본 문법은 `execution` 의 args 부분과 같다.

```java
package hello.aop.pointcut;

import hello.aop.member.MemberServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.aop.aspectj.AspectJExpressionPointcut;

import java.lang.reflect.Method;

@Slf4j
public class ArgsTest {
    Method helloMethod;

    @BeforeEach
    public void init() throws NoSuchMethodException {
        helloMethod = MemberServiceImpl.class.getMethod("hello", String.class);
    }

    private AspectJExpressionPointcut pointcut(Stringexpression) {
        AspectJExpressionPointcutpointcut= new AspectJExpressionPointcut();
pointcut.setExpression(expression);
        returnpointcut;
    }

    @Test
    void args() {
        //hello(String)과 매칭
        Assertions.assertThat(pointcut("args(String)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args(Object)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args()")
                .matches(helloMethod, MemberServiceImpl.class)).isFalse();
        Assertions.assertThat(pointcut("args(..)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args(*)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args(String, ..)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
    }

/**
     * execution(* *(java.io.Serializable)):메서드의 시그니처로 판단(정적)
     * args(java.io.Serializable):런타임에 전달된 인수로 판단(동적)
     */
@Test
    void argsVsExecution() {
        //Args
        Assertions.assertThat(pointcut("args(String)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args(java.io.Serializable)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("args(Object)")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();

        //Execution
        Assertions.assertThat(pointcut("execution(* *(String))")
                .matches(helloMethod, MemberServiceImpl.class)).isTrue();
        Assertions.assertThat(pointcut("execution(* *(java.io.Serializable))") // 매칭 실패
                .matches(helloMethod, MemberServiceImpl.class)).isFalse();
        Assertions.assertThat(pointcut("execution(* *(Object))")
                .matches(helloMethod, MemberServiceImpl.class)).isFalse();
    }
}

```

**exectuion과 args의 차이점**

- `execution` 은 파라미터 타입이 정확하게 매칭되어야 함. `execution`은 클래스에 선언된 정보를 기반으로 판단
- `args` 는 부모 타입을 허용한다. `args` 는 실제 넘어온 파라미터 객체 인스턴스를 보고 판단한다.

> `args` 는 파라미터 바인딩에 주로 사용한다.

## @target, @within

**정의**

- `@target` : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
- `@within` : 주어진 애노테이션이 있는 타입 내 조인 포인트

**설명**

`@target`, `@within` 은 다음과 같이 타입에 있는 애노테이션으로 AOP 적용 여부를 판단함

- `@target(hello.aop.member.annotation.ClassAOP)`
- `@within(hello.aop.member.annotation.ClassAOP)`

**@target vs @within**

- `@target` 는 인스턴스의 모든 메서드를 조인 포인트로 적용한다
- `@within` 는 해당 타입 내에 있는 메서드만 조인 포인트로 적용

→ `@target` 은 부모 클래스의 메서드까지 어드바이스를 다 적용하고, `@within` 은 자기 자신의 클래스에 정의된 메서드에만 어드바이스를 적용한다.

```java
package hello.aop.pointcut;

import hello.aop.member.annotation.ClassAop;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;

@Slf4j
@Import({AtTargetAtWithinTest.Config.class})
@SpringBootTest
public class AtTargetAtWithinTest {

    @Autowired
    Child child;

    @Test
    void success() {
        log.info("child Proxy={}", child.getClass());
        child.childMethod(); // 부모 클래스만 잇는 메서드
        child.parentMethod(); // 부모, 자식 모두 있는 메서드
    }

    static class Config {
        @Bean
        public Parent parent() {
            return new Parent();
        }

        @Bean
        public Child child() {
            return new Child();
        }

        @Bean
        public AtTargetAtWithinAspect atTargetAtWithinAspect() {
            return new AtTargetAtWithinAspect();
        }
    }

    static class Parent {
        public void parentMethod() {}
    }

    @ClassAop
    static class Child extends Parent {
        public void childMethod() {}
    }

    @Slf4j
    @Aspect
    static class AtTargetAtWithinAspect {
        // @target: 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입 메서드도 적용
        @Around("execution(* hello.aop..*(..)) && target(hello.aop.member.annotation.ClassAop)")
        public Object atTarget(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[@target] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }

        // @within: 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입 메서드는 적용되지 않음
        @Around("execution(* hello.aop..*(..)) && within(hello.aop.member.annotation.ClassAop)")
        public Object atWithin(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[@within] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }
    }
}
```

```java
argetAtWithinTest$AtTargetAtWithinAspect : [@target] void hello.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()
argetAtWithinTest$AtTargetAtWithinAspect : [@within] void hello.aop.pointcut.AtTargetAtWithinTest$Child.childMethod()
argetAtWithinTest$AtTargetAtWithinAspect : [@target] void hello.aop.pointcut.AtTargetAtWithinTest$Parent.parentMethod()
```

`parnetMethod()` 는 `Parent` 클래스에만 정의되어 있고, `Child` 클래스에 정의되어 있지 않기 때문에 `@within` 에서 AOP 적용 대상이 되지 않는다.

> `@target`, `@within` 지시자는 뒤에서 설명할 파라미터 바인딩에서 함께 사용된다.

> **주의**
> 다음 포인트컷 지시자는 단독으로 사용하면 안된다. `args`, `@args`, `@target`
> 이번 예제를 보면 execution(_ hello.aop.._(..)) 를 통해 적용 대상을 줄여준 것을 확인할 수 있다.
> args , @args , @target 은 실제 객체 인스턴스가 생성되고 실행될 때 어드바이스 적용 여부를 확인할 수 있다.
> 실행 시점에 일어나는 포인트컷 적용 여부도 결국 프록시가 있어야 실행 시점에 판단할 수 있다. 프록시가 없다면 판단 자체가 불가능하다. 그런데 스프링 컨테이너가 프록시를 생성하는 시점은 스프링 컨테이너가
> 만들어지는 애플리케이션 로딩 시점에 적용할 수 있다. 따라서 args , @args , @target 같은 포인트컷
> 지시자가 있으면 스프링은 모든 스프링 빈에 AOP를 적용하려고 시도한다. 앞서 설명한 것 처럼 프록시가
> 없으면 실행 시점에 판단 자체가 불가능하다.
> 문제는 이렇게 모든 스프링 빈에 AOP 프록시를 적용하려고 하면 스프링이 내부에서 사용하는 빈 중에는
> final 로 지정된 빈들도 있기 때문에 오류가 발생할 수 있다.
> 따라서 이러한 표현식은 최대한 프록시 적용 대상을 축소하는 표현식과 함께 사용해야 한다.

## @annotation, @args

### @annotation

`@annotation` : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭

ex) `@annotation(hello.aop.member.annotation.MethodAop)`

다음과 같이 메서드(조인 포인트)에 애노테이션이 있으면 매칭

```java
public class MemberServiceImpl {
		@MethodAop("test value")
		public String hello(String param) {
				return "ok";
		}
}
```

### @args

`@args` : 전달된 실제 인수의 런타인 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트

전달된 인수의 런타임 타입에 `@Check` 애노테이션이 있는 경우 매칭

ex) `@args(test.Check)`

## bean

`bean` : 스프링 전용 포인트컷 지시자, 빈의 이름으로 지정

- 스프링 빈의 이름으로 AOP 적용 여부를 지정
- `bean(orderService) || bean(*Repository)`
- `*`과 같은 패턴을 사용할 수 있음

```java
package hello.aop.pointcut;

import hello.aop.order.OrderService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

@Slf4j
@Import(BeanTest.BeanAspect.class)
@SpringBootTest
public class BeanTest {

    @Autowired
    OrderService orderService;

    @Test
    void success() {
        orderService.orderItem("itemA");
    }

    @Aspect
    static class BeanAspect {
        @Around("bean(orderService) || bean(*Repository)")
        public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[bean] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }
    }
}
```

## 매개변수 전달

포인트컨 표현식을 사용해서 어드바이스에 매개변수를 전달할 수 있음.

**this, target, args, @target, @within, @annotation, @args**

```java
@Before("allMember() && args(arg, ..))
public void logArgs3(String arg) {
		log.info("[logArgs3] arg={}", arg);
}
```

- 포인트컷의 이름과 매개변수의 이름을 맞추어야 함
- 추가로 타입이 메서드에 지정한 타입으로 제한된다. 여기서는 메서드 타입이 String으로 되어 있기 때문에 다음과 같이 정의되는 것으로 이해하면 됨.
  - `args(arg, ..)` → `args(String, )`

```java
package hello.aop.pointcut;

import hello.aop.member.MemberService;
import hello.aop.member.annotation.ClassAop;
import hello.aop.member.annotation.MethodAop;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

@Slf4j
@Import(ParameterTest.ParameterAspect.class)
@SpringBootTest
public class ParameterTest {

    @Autowired
    MemberService memberService;

    @Test
    void success() {
        log.info("memberService Proxy={}", memberService.getClass());
        memberService.hello("helloA");
    }

    @Slf4j
    @Aspect
    static class ParameterAspect {

        @Pointcut("execution(* hello.aop.member..*.*(..))")
        private void allMember() {}

        @Around("allMember()")
        public Object logArgs1(ProceedingJoinPoint joinPoint)
                throws Throwable {
            Object arg1 = joinPoint.getArgs()[0];
            log.info("[logArgs1]{}, arg={}", joinPoint.getSignature(), arg1);
            return joinPoint.proceed();
        }

        @Around("allMember() && args(arg, ..)")
        public Object logArgs2(ProceedingJoinPoint joinPoint, String arg)
                throws Throwable {
            log.info("[logArgs2]{}, arg={}", joinPoint.getSignature(), arg);
            return joinPoint.proceed();
        }

        @Before("allMember() && args(arg, ..)")
        public void logArgs3(String arg) throws Throwable {
            log.info("[logArgs3] arg={}", arg);
        }

        @Before("allMember() && this(obj)")
        public void thisArgs(JoinPoint joinPoint, MemberService obj)
                throws Throwable {
            log.info("[this]{} obj={}", joinPoint.getSignature(), obj.getClass());
        }

        @Before("allMember() && target(obj)")
        public void targetArgs(JoinPoint joinPoint, MemberService obj)
                throws Throwable {
            log.info("[target]{} obj={}", joinPoint.getSignature(), obj.getClass());
        }

        @Before("allMember() && @target(annotation)")
        public void atTarget(JoinPoint joinPoint, ClassAop annotation)
                throws Throwable {
            log.info("[@target]{} obj={}", joinPoint.getSignature(), annotation.getClass());
        }

        @Before("allMember() && @within(annotation)")
        public void atWithin(JoinPoint joinPoint, ClassAop annotation)
                throws Throwable {
            log.info("[@within]{} obj={}", joinPoint.getSignature(), annotation.getClass());
        }

        @Before("allMember() && @annotation(annotation)")
        public void atWithin(JoinPoint joinPoint, MethodAop annotation)
                throws Throwable {
            log.info("[@annotation]{} annotationValue={}", joinPoint.getSignature(), annotation.value());
        }
    }
}
```

- `logArgs1` : `joinPoint.getArgs()[0]` 와 같이 매개변수를 전달 받는다.
- `logArgs2` : `args(arg,..)` 와 같이 매개변수를 전달 받는다.
- `logArgs3` : `@Before` 를 사용한 축약 버전이다. 추가로 타입을 String 으로 제한했다.
- `this` : 프록시 객체를 전달 받는다.
- `target` : 실제 대상 객체를 전달 받는다.
- `@target` , `@within` : 타입의 애노테이션을 전달 받는다.
- `@annotation` : 메서드의 애노테이션을 전달 받는다. 여기서는 annotation.value() 로 해당

애노테이션의 값을 출력하는 모습을 확인할 수 있다.

## this, target

- `this` : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인포인트
- `target` : Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
- `this`, `target` 은 다음과 같이 적용 타입 하나를 정확하게 지정해야 한다.

```java
this(hello.aop.member.MemberService)
target(hello.aop.member.MemberService)
```

- `*` 같은 패턴을 사용할 수 없음
- 부모 타입 허용

**this vs target**

스프링에서 AOP를 적용하면 실제 `target` 객체 대신에 프록시 객체가 스프링 빈으로 등록된다.

- `this` 는 스프링 빈으로 등록되어 있는 **프록시 객체**를 대상으로 포인트컷을 매칭
- `target` 은 실제 **target 객체**를 대상으로 포인트컷을 매칭

**JDK 동적 프록시**

**MemberService 인터페이스 지정**

- `this(hello.aop.member.MemberService)`
  - proxy 객체를 보고 판단한다. `this` 는 부모 타입을 허용하기 때문에 AOP가 적용된다.
- `target(hello.aop.member.MemberService)`
  - target 객체를 보고 판단한다. `target`는 부모 타입을 허용하기 때문에 AOP가 적용된다.

**MemberServiceImpl 구체 클래스 지정**

- `this(hello.aop.member.MemberServiceImpl)` : proxy 객체를 보고 판단한다. JDK 동적 프록시로

만들어진 proxy 객체는 `MemberService` 인터페이스를 기반으로 구현된 새로운 클래스다. 따라서 MemberServiceImpl 를 전혀 알지 못하므로 **AOP 적용 대상이 아니다.**

- `target(hello.aop.member.MemberServiceImpl)` : target 객체를 보고 판단한다. target 객체가
  MemberServiceImpl 타입이므로 AOP 적용 대상이다.

**CGLIB 프록시**

**MemberService 인터페이스 지정**

- `this(hello.aop.member.MemberService)` : proxy 객체를 보고 판단한다. this 는 부모 타입을

허용하기 때문에 AOP가 적용된다.

- `target(hello.aop.member.MemberService)` : target 객체를 보고 판단한다. target 은 부모 타입을

허용하기 때문에 AOP가 적용된다.

**MemberServiceImpl 구체 클래스 지정**

- `this(hello.aop.member.MemberServiceImpl)` : proxy 객체를 보고 판단한다. CGLIB로 만들어진 proxy 객체는 MemberServiceImpl 를 상속 받아서 만들었기 때문에 AOP가 적용된다. this 가 부모
  타입을 허용하기 때문에 포인트컷의 대상이 된다.
- `target(hello.aop.member.MemberServiceImpl)` : target 객체를 보고 판단한다. target 객체가
  MemberServiceImpl 타입이므로 AOP 적용 대상이다.

```java
package hello.aop.pointcut;

import hello.aop.member.MemberService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

/**
 * application.properties
 * spring.aop.proxy-target-class=true   CGLIB    default
 * spring.aop.proxy-target-class=false  JDK 동적 프록시
 */
@Slf4j
@Import(ThisTargetTest.ThisTargetAspect.class)
@SpringBootTest(properties = "spring.aop.proxy-target-class=false")
//@SpringBootTest
public class ThisTargetTest {

    @Autowired
    MemberService memberService;

    @Test
    void success() {
        log.info("memberService Proxy={}", memberService.getClass());
        memberService.hello("helloA");
    }

    @Slf4j
    @Aspect
    static class ThisTargetAspect {

        // 부모 타입 허용
        @Around("this(hello.aop.member.MemberService)")
        public Object doThisInterFace(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[this-interface] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }

        @Around("target(hello.aop.member.MemberService)")
        public Object doTargetInterFace(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[target-interface] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }

        @Around("this(hello.aop.member.MemberServiceImpl)")
        public Object doThis(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[this-impl] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }

        @Around("target(hello.aop.member.MemberServiceImpl)")
        public Object doTarget(ProceedingJoinPoint joinPoint) throws Throwable {
            log.info("[target-impl] {}", joinPoint.getSignature());
            return joinPoint.proceed();
        }
    }
}
```

- `properties = {"spring.aop.proxy-target-class=false"}` : application.properties 에 설정하는 대신에 해당 테스트에서만 설정을 임시로 적용한다. 이렇게 하면 각 테스트마다 다른 설정을 손쉽게 적용할 수 있다.
- `spring.aop.proxy-target-class=false` : 스프링이 AOP 프록시를 생성할 때 JDK 동적 프록시를 우선 생성한다. 물론 인터페이스가 없다면 CGLIB를 사용한다.
- `spring.aop.proxy-target-class=true` : 스프링이 AOP 프록시를 생성할 때 CGLIB 프록시를 생성한다. 참고로 이 설정을 생략하면 스프링 부트에서 기본으로 CGLIB를 사용한다. 이 부분은 뒤에서 자세히 설명한다.

> **참고**
> `this` , `target` 지시자는 단독으로 사용되기 보다는 파라미터 바인딩에서 주로 사용됨
