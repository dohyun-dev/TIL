## 템플릿 메서드 패턴

> V0의 경우 코드에 핵심 기능만 있어 코드가 전체적으로 깔끔하다. 하지만 V3의 경우 부가기능이 추가되면서 비즈니스 로직을 알아보기가 힘들다. 또한 부가기능이 추가 됨으로써 코드가 반복되고 있다.

`변하는 것과 변하지 않는 것을 분리` → `부가기능을 모듈화 시켜야함`

아래와와 같이 똑같은 로직의 메서드가 반복되고 있다.

이를 해결해주는 것이 템플릿 메서드 패턴이다.

```java
package hello.advanced.app.trace.template;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

@Slf4j
public class TemplateMethodTest {

    @Test
    void templateMethodV0() {
        logic1();
        logic2();
    }

    private void logic1() {
        long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
				log.info("비즈니스 로직1 실행");
        // 비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
				log.info("resultTime={}", resultTime);
    }

    private void logic2() {
        long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
				log.info("비즈니스 로직2 실행");
        // 비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
				log.info("resultTime={}", resultTime);
    }
}
```

## 템플릿 메서드 - 예제

아래와 같이 변하지 않는 부분을 추상클래스에서 구현하고 변하는 부분을 자식클래스에서 구현하게 한다

```java
package hello.advanced.app.trace.template.code;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class AbstractTemplate {

    public void execute() {
        longstartTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        call();
        // 비즈니스 로직 종료
        longendTime = System.currentTimeMillis();
        longresultTime = endTime - startTime;
				log.info("resultTime={}", resultTime);
    }

    protected abstract void call();
}
```

테스트 코드 작성

```java
/**
     * 템플릿 메서드 패턴 적용
     */
    @Test
    public void TemplateMethodV1() {
        AbstractTemplate template1 = new SubClassLogic1();
        template1.execute();

        AbstractTemplate template2 = new SubClassLogic2();
        template2.execute();
    }
```

결과

```
01:58:54.067 [Test worker] INFO hello.advanced.app.trace.template.code.SubClassLogic1 - 비즈니스 로직1 실행
01:58:54.072 [Test worker] INFO hello.advanced.app.trace.template.code.AbstractTemplate - resultTime=6
01:58:54.074 [Test worker] INFO hello.advanced.app.trace.template.code.SubClassLogic2 - 비즈니스 로직2 실행
01:58:54.075 [Test worker] INFO hello.advanced.app.trace.template.code.AbstractTemplate - resultTime=1
```

### 익명 내부클래스를 사용한 템플릿 메서드

```java
@Test
    public void TemplateMethodV2() {
        AbstractTemplate template1 = new AbstractTemplate() {
            @Override
            protected void call() {
                log.info("비즈니스 로직1 실행");
            }
        };

        AbstractTemplate template2 = new AbstractTemplate() {
            @Override
            protected void call() {
                log.info("비즈니스 로직2 실행");
            }
        };
        template2.execute();
    }
```

익명 내부클래스는 다음과 같이 이름이 메서드 $숫자로 지정된다

```java
02:08:28.933 [Test worker] INFO hello.advanced.app.trace.template.TemplateMethodTest - 익명 내부클래스1의 이름=hello.advanced.app.trace.template.TemplateMethodTest$1
02:08:28.939 [Test worker] INFO hello.advanced.app.trace.template.TemplateMethodTest - 익명 내부클래스2의 이름=hello.advanced.app.trace.template.TemplateMethodTest$2
```

### 인텔리제이 단축키

`Cmd - Option - n : inline Variable`

`Ctrl - t : Refactoring`

`Cmd - Option - t : surround`

## 템플릿 메서드 적용

```java
package hello.advanced.app.trace.template;

import hello.advanced.app.trace.TraceStatus;
import hello.advanced.app.trace.logtrace.LogTrace;

public abstract class AbstractTemplate<T> {

    private final LogTrace trace;

    protected AbstractTemplate(LogTrace trace) {
        this.trace = trace;
    }

    public T execute(String message) {
        TraceStatus status = null;
        try {
            status = trace.begin(message);

            // 로직 호출
            T result = call();

            trace.end(status);
            return result;
        } catch (Exception e) {
            trace.exception(status, e);
            throw e;
        }
    }

    protected abstract T call();
}
```

```java
package hello.advanced.app.v4;

import hello.advanced.app.trace.TraceStatus;
import hello.advanced.app.trace.logtrace.LogTrace;
import hello.advanced.app.trace.template.AbstractTemplate;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class OrderControllerV4 {

    private final OrderServiceV4 orderService;
    private final LogTrace trace;

    @GetMapping("/v4/request")
    public String request(String itemId) {
        AbstractTemplate<String> template = new AbstractTemplate<>(trace) {

            @Override
            protected String call() {
                orderService.orderItem(itemId);
                return "ok";
            }
        };
        String execute = template.execute("OrderController.request()");
        return execute;
    }
}
```

```java
package hello.advanced.app.v4;

import hello.advanced.app.trace.logtrace.LogTrace;
import hello.advanced.app.trace.template.AbstractTemplate;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class OrderServiceV4 {

    private final OrderRepositoryV4 orderRepository;
    private final LogTrace trace;

    public void orderItem(String itemId) {
        AbstractTemplate<Void> template = new AbstractTemplate<Void>(trace) {
            @Override
            protected Void call() {
                orderRepository.save(itemId);
                return null;
            }
        };
        template.execute("OrderService.orderItem()");
    }
}
```

```java
package hello.advanced.app.v4;

import hello.advanced.app.trace.logtrace.LogTrace;
import hello.advanced.app.trace.template.AbstractTemplate;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;

@Repository
@RequiredArgsConstructor
public class OrderRepositoryV4 {

    private final LogTrace trace;

    public void save(String itemId) {
        AbstractTemplate<Void> template = new AbstractTemplate<Void>(trace) {
            @Override
            protected Void call() {

                if (itemId.equals("ex"))
                    new IllegalArgumentException("예외 발생!");
                sleep(1000);
                return null;
            }
        };
        template.execute("OrderService.orderItem()");

    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

> 템플릿 메서드 패턴을 적용해서 단일 책임 원칙(SRP)를 지킨 것이다.

### 템플릿 메서드

- 부모 클래스에 알고리즘의 골격인 템플릿을 정의, 일부 변경되는 로직은 자식 클래스에 정의하는 것
  → 상속과 오버라이딩을 통한 다형성으로 문젤를 해결하는 것
- 상속에서 오는 단점들을 그대로 안고감
  - 컴파일 시점 자식클래스가 부모 클래스와 강결합 발생
  - 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않음 → 자식클래스가 부모클래스를 강하게 의존 → 좋은 설계가 아님

> 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴 → 전략 패턴(Strategy Pattern)
